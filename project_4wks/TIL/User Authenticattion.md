# 세션 기반 인증 방식과 토큰 기반 인증(JWT)

## 세션 기반 인증 방식

- 옛날에 토큰 기반 인증이 없었을 때 서버 세션을 이용해 인증을 했다.

  1. 클라이언트가 로그인
  2. 성공하면 서버가 유저 세션을 만들고 메모리나 데이터베이스가 저장한다.
  3. 클라이언트의 브라우저에 세션의 ID만 쿠키에 저장하게 한다.

  세션 데이터가 서버의 메모리에 저장되므로, 확장 시 모든 서버가 접근할 수 있도록 별도의 중앙 세션 관리 시스템이 필요한다.

  **단점**

  - 중앙 세션 관리 시스템이 없으면 시스템 확장에 어려움이 생긴다.
  - 중앙 세션 관리 시스템이 장애가 일어나면, 시스템 전체가 문제가 생긴다.
  - 만약 메모리에 세션 정보가 들어 있다면, 메모리가 많이 사용될 수 있다.

  규모 확장이 필요 없는 소규모 프로그램 작성에서는 세션 기반 인증방식을 사용해도 상관 없을 것이다.

## JWT

- JWT(Json Web Token)은 토큰 기반 인증 방식으로, 클라이언트의 세션 상태를 저장하는 게 아니라 필요한 정보를 토큰 body에 저장해 클라이언트가 가지고 있고 그것을 증명서처럼 사용한다.

- 기본 구성

  ````javascript
  xxxx.yyyy.zzzz
  ````

  - **Header(xxxx)** JWT인 토큰의 유형이나 HMAC SHA256 또는 RSA와 같이 사용되는 해시 알고리즘이 무엇으로 사용했는지 등 정보가 담긴다. Base64 Url로 인코딩 되어있다.
  - **Payload(yyyy)** 클라이언트에 대한 정보나, mata Data 같은 내용이 들어있고, Base64 Url로 인코딩 되어있다. 
    JWT는 내용을 해독해 볼 수 있으므로, 이곳에 중요한 데이터를 포함해서는 안된다.
    [jwt.io](https://jwt.io/)이곳에서 jwt를 해독할 수 있다.
  - **Signature(zzzz)** header에서 지정한 알고리즘과 secret키, 서명으로 payload와 header를 담는다.

- JWT 보안 위험

  * JWT는 자체 내에 정보를 가지고 있기 대문에 클라이언트가 해독해 정보를 볼 수 있다. 하지만 받는 자가 secret 키를 알고 있어야만 수정이 가능하다.
    - **작동 원리**
      1. A가 B에게 JWT를 한다.
      2. A, B 둘 다 암호화한 secret 키를 알고 있다.
      3. C는 secret 키를 알지 못하지만, A, B사이의 JWT를 몰래 변경하려 한다.
      4. A는 이를 방지하기 위해 signature부분에 ( payload + secret key )를 특정 알고리즘으로 해시화 해 추가했다.
      5. C가 이 JWT를 변경하려 해도 secret key를 몰라 멋대로 변겅 할 수 없다.
      6. B는 C가 변경한 JWT를 받으면 서명이 다르기 때문에 받지 않는다.
    - 수명
      JWT의 수명을 짧게 하고 정기적으로 재발급을 요구하면 원치 않는 클라이언트를 빨리 막을 수 있다.
    - 기본 인증 과정
      간단한 JWT 인증 처리 과정이다.
      1. 클라이언트가 로그인을 하면, 서버로부터 `access` 토큰을 부여 받는다.
      2. 이후 클라이언트가 모든 api 요청을 할 때 `access`토큰을 포함 시킨다.
      3. 서버는 `access` 토큰을 해독해 확인하고 검증되면 해당 api 기능을 수행한다.
      4. 기한이 만료되었으면 `access`토큰을 지워주고 재로그인을 하게 한다.
    - **문제점**
      - 클라이언트가 계속 시스템을 이용하다가 `access`토큰 기한이 만료된다면 사용 중에 갑자기 로그인을 하라고 할 것이다.
      - 수명이 짧다면 만료될 때마다 로그인을 해주어야 한다.
      - 수명이 길면 해커에게 해독 되어 사용될 가능성이 높아진다.
    - **Refresh Token**
      `access` 토큰이 만료되었을 때, **Refresh Token**으로 새로운 토큰을 발급 받을 수 있다.
    - **필요성**
      - 서버 데이터베이스에 Refresh Token이 저장되어 있을 때 클라이언트가 블랙리스트에 포함되어 있다면 토큰을 발급해주는 것을 막을 수 있다.
      - Refresh Token으로 access 토큰이 만료되면 알아서 갱신한다.
      - 웹과 모바일에서의 JWT 저장
        **React-Native**로 개발한 모바일 앱에서는 Key Chain 이나 Key Store에서 암호화 되게 JWT를 저장할 수 있는 라이브러리가 있다.
        하지만 웹에서는 2가지의 선택이 있다.
        - Cokkies
          쿠키는 `http-only`플래그를 사용해 암호화된 쿠키가 https로만 통신하도록 설정해 XSS의 문제를 완화시킬 수 있다.
          하지만, `CSRF`(최근에 인증된 사용자가 웹 프로그램에서 원치 않는 행위를 하도록 한다.)공격의 위험이 있다. 이는 `CSURF`같은 라이브러리를 사용하면 예방 할 수 있다.
          그래서 보안을 위해 보통 Cookie 사용을 권장한다.
        - local/ session storage
          동일한 도메인의 JS를 통해 접근할 수 있으므로, XSS공격에 취약하다.

# JWT(Json Web Token)을 이용한 모바일 인증

## 모바일 API 보안의 문제점

가장 기초적인 API 보안의 형태는 HTTP Basic Authentication(HTTP 기본 인증)이다. 이 방식은 매우 간결하게 작동하기 때문에 API의 서버를 만드는 사람이나 API를 활용할 개발자 모두에게 편리함을 제공 해준다.
HTTP 기본 인증 방식은 간결하면서 훌륭한 인증 방식이다. 개발자는 API키를 발급받는 것 만으로 API서비스를 간편하게 사용 할 수 있다.
HTTP 기본 인증 방식이 모바일 앱에 적합하지 않은 이유는 API키를 모바일 기기 내에 안전하게 저장하는 이슈 때문이다.
또한 HTTP 기본 인증 방식은 Raw한 API키를 매 요청 때 마다 사용해야 하므로, 시간이 갈수록 취약점 공격에 노출 될 가능성이 높아진다. 또한 API키가 내장된 채로 배포된 앱을 리버스 엔지니어링하면 API키를 알아내는 것이 가능해지기 때문에 API 서비스가 악용될 소지가 있다. 대부분의 경우 다수에게 배포되는 모바일 앱 내에 안전하게 API키를 보관하는 방법은 없다고 볼 수 있다.
때문에 HTTP 기본 인증방식은 웹 브라우저나 모바일 앱 같은 신뢰하기 힘든 환경에 적합한 인증방식은 아니다.

## 모바일 API 보안에 OAuth2도입하기

OAuth2는 신뢰하기 어려운 기기(모바일)에서 사용되는 API서비스 보안을 위한 훌륭한 프로토콜이다. 또한 모바일 사용자를 인증할 수 있는 수단으로 토큰 인증방식을 제공한다. 사용자의 관점에서 OAuth2 은 다음과 같이 진행된다.
(OAuth2는 이 프로세스를 Password Grant Flow라고 부른다.)

1. 사용자가 모바일 앱을 실행하고, ID혹은 메일 주소와 비밀번호를 입력하는 창이 뜬다.
2. 모바일 앱에서 입력 받은 사용자의 정보를 POST 방식으로 API서버로 보낸다 (SSL)
3. 유저 인증 값을 검증하고 일정 시간이 지나면 만료될 액세스 토큰을 생성한다.
4. 발급받은 액세스 토큰을 모바일 기기에 저장한다. API토큰과 마찬가지로 보안이 적용되는 안전한 장소에 보관해야 하며, API서비스에 접근할 때 이 토큰을 사용한다.
5. 액세스 토큰이 만료되면 더이상 작동하지 않으며, ID혹은 메일 주소와 비밀번호를 입력하는 창을 다시 띄운다

OAuth2가 API보안에 좋은 이유는 API키 자체를 안전하지 않은 환경에 저장할 필요가 없기 때문이다. 대신에 액세스 토큰을 생성하여 안전하지 않은 환경에 임시로 저장해놓기만 하면 된다. 공격자가 액세스 토큰에 접근할 수 있게 되더라도 일정 시간이 지나면 만료되기 때문에 잠재적인 피해를 줄일 수 있다.
OAuth2에서 API에 접근할 때 필요한 액세스 토큰을 발급 받았다면, 모바일 기기 어딘가에 저장을 해야 한다. 토큰 저장 장소는 개발을 진행하는 플랫폼에 따라 정해진다. 예를 들어 안드로이드 앱을 개발하고 있다면 모든 액세스 토큰을 `SharedPerference`에 저장할 것이다. IOS의 경우 액세스 토큰을 `KeyChain`에 저장하게 된다 
(이 둘을 

